var l=class{defaultRequestTimeout=1e3;#n="__WAITER_CONFIG_COMMON__";#t="[Waiter]";#r;#e;#o=32;constructor(t={}){let{namespace:e,outputPrefix:o,authToken:i,encryptionKey:s}=t;this.#n=e||this.#n,this.#t=o||this.#t,this.#r=i,this.#e=s,this.#c()||this.#a()}get config(){return window[this.#n]}createController(t,e,o){if(this.#r&&this.#r!==o)throw new Error(`${this.#t} Invalid authentication token for endpoint: "${t}".`);if(this.config.controllers.has(t))throw new Error(`${this.#t} Endpoint: "${t}", already exists.`);let i=async(s,c)=>{try{let r=this.#e?await this.#s(s):s,a=await e(r),n=this.#e?await this.#i(a):a;c(n)}catch(r){throw r}};this.config.controllers.set(t,i)}removeController(t,e){if(this.#r&&this.#r!==e)throw new Error(`${this.#t} Invalid authentication token for endpoint: "${t}".`);if(!this.config.controllers.has(t))throw new Error(`${this.#t} Endpoint: "${t}", not found.`);this.config.controllers.delete(t)}async request(t,e,o){if(!this.config.controllers.has(t))throw new Error(`${this.#t} Endpoint: "${t}", not found.`);let i=this.#e?await this.#i(e):e;return new Promise(async(s,c)=>{let r=setTimeout(()=>c(new Error(`${this.#t} Request to endpoint: "${t}", timed out.`)),o?.timeout||this.defaultRequestTimeout),a=async n=>{clearTimeout(r);let y=this.#e?await this.#s(n):n;return s(y)};try{this.config.controllers.get(t)?.(i,a)}catch(n){clearTimeout(r),c(n)}})}#a(){window[this.#n]={controllers:new Map}}#c(){return this.config!==void 0}async#i(t){if(!this.#e)throw new Error(`${this.#t} Encryption key not provided.`);try{let e=JSON.stringify(t),o=new TextEncoder,i=o.encode(e),s=o.encode(this.#e),c=await crypto.subtle.importKey("raw",s.slice(0,this.#o),{name:"AES-GCM"},!1,["encrypt"]),r=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},c,i),n=new Uint8Array(r.length+a.byteLength);return n.set(r),n.set(new Uint8Array(a),r.length),btoa(String.fromCharCode(...n))}catch(e){throw new Error(`${this.#t} Encryption failed: ${e}`)}}async#s(t){if(!this.#e)throw new Error(`${this.#t} Encryption key not provided.`);try{let e=new Uint8Array(atob(t).split("").map(h=>h.charCodeAt(0))),o=e.slice(0,12),i=e.slice(12),c=new TextEncoder().encode(this.#e),r=await crypto.subtle.importKey("raw",c.slice(0,this.#o),{name:"AES-GCM"},!1,["decrypt"]),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},r,i),y=new TextDecoder().decode(a);return JSON.parse(y)}catch(e){throw new Error(`${this.#t} Decryption failed: ${e}`)}}};export{l as default};
//# sourceMappingURL=waiter.mjs.map
